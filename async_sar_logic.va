// VenlogA for Z_adc, sar_adc_logic_async, venloga
// Function: Asynchronous SAR logic for monotonic switching
// Author: xueyong
// Date: 2022-08-08

'include "constants.vams"
'include "disciplines.vams"

module sar_adc_logic_async_4b (clk_conv, rstn, qp, qn, clk_cmp, clk_reg, convert, eoc, ctrlp, ctrln, dout);

`define NumOfBits 4 //8
`define clog2(x) \
((x <= 1) || (x > 512)) ? 0 : \
(x <= 2) ? 1 : \
(x <= 4) ? 2 : \
(x <= 8) ? 3 : \
(x <= 16) ? 4 : \
(x <= 32) ? 5 : \
(x <= 64) ? 6 : \
(x <= 128) ? 7: \
(x <= 256) ? 8: \
(x <= 512) ? 9 : 0


//signals
input clk_conv; //conversion clk, =!clk_sample
input rstn;
input qp; //output of dynamic comparator
input qn; //output of dynamic comparator
output clk_cmp; //high speed clock for dynamic comparator, generated by delay of !(qp | qn), the frequency is set by parameter f_clk_cmp
output clk_reg; //high speed clock for registers, generated by (qp | qn), same frequecy as clk_cmp with a phase shift
output convert; //convertsion enable signal, goes high at he rising edge of clk_conv and goes low at the rising edge of eoc
output eoc; //end of conversion
output [`Num0fBits-2:0] ctrlp ; //output DAC code for p terminal
output [`NumOfBits-2:0] ctrln ; //output DAC code for n terminal
output [`NumOfBits-l:0] dout ; //output ADC code (w/o elk syn)

//voltages
voltage clk_conv;
voltage rstn;
voltage qp;
voltage qn;
voltage clk_cmp;
voltage clk_reg;
voltage convert;
voltage eoc;
voltage [`NumOfBits-2:0] ctrlp; 
voltage [`NumOfBits-2:0] ctrln; 
voltage [`NumOfBits-1:0] dout;


//internal paramters
parameter real vdd = 1;
parameter real vss = 0;
parameter real vth = 0.5;
parameter real td = 10p from [0: inf);
parameter real tt = 10p from [0: inf);
parameter real f_clk_cmp = 20G from [0: inf); //make sure conversion can be done during clk_conv high, f_clk_cmp > NumOfBits * f_clk_conv 
parameter integer dir = 0;
parameter integer dir_pos = +1;
parameter integer dir_neg = -1;
integer counter;
genvar i;

//internal signals 
integer i_rstn; 
integer i_ctrlp; 
integer i_ctrln; 
integer i_eoc; 
integer i_convert; 
integer i_dout; 
integer i_qp; 
integer i_qn; 
integer i_clk_conv; 
integer i_clk_cmp; 
integer i_clk_reg; 
integer result;

voltage eocdly; 
integer i_eoc_dly;


analog begin
  @(initial_step) begin
    counter   = 0;
    i_ctrlp   = pow(2, NumOfBits-1)-1;//127;
    i_ctrln   = pow(2, NumOfBits-1)-1;//127;
    i_eoc     = 0;
    result    = 0;
    i_convert = 0;
  end // @inital_step

  //convert enable gen
  i_rstn = V(rstn) > vth ? 1: 0;
  i_clk_conv = V(clk_conv) > vth ? 1: 0;
  //RS flipflop to generate convert enable signal 
  @(cross(i_clk_conv - vth , dir_pos)) begin
    if (i_rstn) i_convert = 1;
  end
  @(cross(i_eoc - vth , dir_pos)) begin
    if (i_rstn) i_convert = 0;
  end
  V(convert) <+ transition (i_convert ? vdd : vss, td, tt);

  //clk_ref gen based on qp, qn
  i_qp = V(qp) > vth ? 1: 0;
  i_qn = V(qn) > vth ? 1: 0;
  i_clk_reg = (i_qp | i_qn); // qp OR qn
  V(clk_reg) <+ transition ((i_clk_reg & i_convert) ? vdd : vss, td, tt);


  //clk_cmp gen based on the delay, i.e. 1/(2*f_clk_cmp)
  if (i_convert) begin
    //i_clk_cmp = absdelay(!(i_qp | i_qn), 1/(2*f_clk_cmp
    i_clk_cmp = !(i_qp | i_qn);
  end
  //N(clk_cmp) <+ transition(i_clk_cmp ? vdd : vss , td, tt);
  V(clk_cmp) <+ transition((i_clk_cmp & i_convert) ? vdd : vss , 1/(2*f_clk_cmp), tt);


  /////////////////
  //register logic
  /////////////////
  @(cross(i_convert - vth , dir_pos)) begin
    // When convert goes high
    counter = `NumOfBits;
    i_ctrlp = pow(2, NumOfBits-1)-1;//127;
    iictrin = pow(2, NumOfBits-1)-1;//127;
    i_eoc   = 0;
    result  = pow(2, NumOfBits+1)-1;//511; 
    //$strobe(">>>>>>>>>>>>>>>debug_1>>>>>>>>>>>>>>>counter = (%E).\n", counter);
  end

  @(cross(i_clk_reg - vth , dir_neg)) begin
    if (counter > 0) begin
      counter = counter - 1;
      //$display (">>>>>>>>>>>>>>>debug_1>>>>>>>>>>>>>>>coun ter = (%E).\n", counter);
      //$display (">>>>>>>>>>>>>>>debug_1>>>>>>>>>>>>>>>time = (%E).\n", $abstime);
    end
    if (counter == 0)begin
      i_eoc = 1;
      i_dout = result;
    end
    else begin
      i_eoc = 0; 
    end
  end

  @(cross(i_clk_reg - vth , dir_pos)) begin
    if (V(qp) > V(qn)) begin
      //$display (">>>>>>>>>>>>>>>debug_2>>>>>>>>>>>>>>>time = (%E).\n", $abstime);
      result = result & ~(1<<(counter - 1));
      i_ctrlp = i_ctrlp & ~(1<<(counter - 2)); //set ctrlp[counter-1]=0, keep other bits
      //$display (">>>>>>>>>>>>>>>debug_2>>>>>>>>>>>>>>>counter = (%E).\n", counter);
    end
    else if (V(qp) < V(qn)) begin
      i_ctrln = i_ctrln & ~(1<<(counter - 2)); //set ctrln[counter-1]=0, keep other bits
      //$display (">>>>>>>>>>>>>>>debug_2>>>>>>>>>>>>>>>i_ctrln = (%E).\n", i_ctrln);
    end
  end

  //reset ctrlp, ctrln to all â€œ1"s for sampling 
  @(cross(i_clk_conv - vth , dir_neg)) begin
    i_ctrlp = pow(2, NumOfBits-1)-1;
    i_ctrln = pow(2, NumOfBits-1)-1;
  end

  for (i=0; i<`NumOfBits; i=i+1)begin
    V(dout[{i]) <+ transition(i_dout & (l<<i) ? vss : vdd, td, tt); end
  for (i=0; i<`NumOfBits-1; i=i+1) begin
    V(ctrlp[i]) <+ transition (i_ctrlp & (l<<i) ? vss : vdd, td, tt); //NOTE: in DAC, the cap ties to Vrefp when ctrl signal is 0
    V(ctrln[i]) <+ transition (i_ctrln & (l<<i) ? vss : vdd, td, tt);
  end

  //eoc flag gen
  i_eoc_dly = V(eoc_dly) > vth ? 1: 0;
  V(eoc_dly) <+ transition (i_eoc ? vdd : vss, 1/(f_clk_cmp), tt); // delay to generate eoc pulse
  V(eoc) <+ transition ((i_eoc & !i_eoc_dly) ? vdd : vss, td, tt);


end // analog begin
endmodule
